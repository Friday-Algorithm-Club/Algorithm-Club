"""
특정 사람이 자신의 간접 부하들에게 가장 빨리 전화를 돌리기 위해서는 
직속 부하중 간접 부하에게 전화를 돌리는데 가장 오랜시간이 걸리는 직속 부하에게 우선적으로 전화해야한다.
따라서 특정 사람의 전화에 걸리는 시간을 구하기 위해선 그 사람의 직속 부하라는 부문제를 해결해아 한다. => dp

일반적인 dp일 경우 리프 노드에서부터 시작해 루프 노드로 진행하는 바텀업 방식으로 풀 수 있겠지만 이 문제의 경우
탑다운 방식으로 풀어야 한다. 왜냐하면 자식 노드의 부문제가 어떻게 해결되느냐에 따라 상위 노드의 부문제 해결 방향이 달라지기 때문이다.

예를 들면, 자식 노드들 중 해결값이 가장 높은 노드가 하나일 경우, 상위 노드의 부문제는 해당 자식 노드에게 우선적으로 먼저 전화를 돌리는 것으로 해결된다.
하지만 자식 노드들 중 해결값이 가장 높은 노드가 여러 개일 경우, 상위 노드의 부문제는 해결 값이 같은 자식 노드들에게 우선적으로 전화를 돌리되
한 번에 하나의 자식 노드들에게 전화를 돌리는 것으로 해결된다. 즉, 상위 노드의 부문제는 해결 값 + (해결 값이 가장 높은 자식 노드의 갯수 - 1)이 된다.
"""
import sys
sys.setrecursionlimit(10**6)

N = int(input())
parent = list(map(int, input().split()))
edge = [[] for _ in range(N)]
dp = [0 for _ in range(N)]

for i in range(1, N):
    edge[parent[i]].append(i)

def dfs(current):
    child = []

    # 자식 노드들에 대한 부문제 해결.
    for e in edge[current]:
        dfs(e)
        child.append(dp[e])

    # 가장 먼저 전화를 돌려야 할 자식 노드들을 찾기 위해 부문제 해결값이 큰 순으로 정렬.
    child.sort(reverse=True)
    res = 0
    for i in range(len(child)):
        # 자식 노드 부문제의 해결 값은 (자식 노드가 부문제 해결에 필요한 정량 값) + (해결 순서에 따른 보정치) + (1: 전화 전파에 걸리는 시간)
        time = child[i] + i + 1
        res = max(res, time)

    dp[current] = res

dfs(0)
print(dp[0])
